<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Traffic Lab 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* UI OVERLAY */
        #ui {
            position: absolute; top: 0; left: 0; padding: 20px;
            color: #fff; pointer-events: none;
            width: 300px;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }
        
        .panel {
            background: rgba(0, 10, 20, 0.85);
            border: 1px solid #00cccc;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            margin-bottom: 10px;
        }

        h1 { margin: 0 0 10px 0; font-size: 16px; letter-spacing: 2px; color: #00ffff; text-transform: uppercase; border-bottom: 1px solid #005555; padding-bottom: 5px;}
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; font-family: monospace; }
        .val { color: #ff00ff; font-weight: bold; }

        /* CONTROLS */
        button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00cccc;
            color: #00ffff;
            padding: 8px; width: 100%;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 1px;
        }
        button:hover { background: #00cccc; color: #000; box-shadow: 0 0 15px #00cccc; }
        
        input[type=range] { width: 100%; accent-color: #ff00ff; }
        label { font-size: 10px; color: #aaa; text-transform: uppercase;}

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui">
        <div class="panel">
            <h1>Traffic OS v9.0</h1>
            <div class="stat-row"><span>Alg:</span> <span id="ui-algo">SMART AI</span></div>
            <div class="stat-row"><span>Phase:</span> <span id="ui-phase" style="color:lime">H_GREEN</span></div>
            <div class="stat-row"><span>Cars:</span> <span id="ui-cars" class="val">0</span></div>
            <div class="stat-row"><span>Throughput:</span> <span id="ui-cpm" class="val">0</span>/min</div>
        </div>

        <div class="panel">
            <h1>System Control</h1>
            <label>Spawn Rate (H / V)</label>
            <input type="range" min="1" max="100" value="40" id="rate-h">
            <input type="range" min="1" max="100" value="30" id="rate-v" style="margin-bottom:10px">
            
            <button onclick="toggleCam()">ðŸŽ¥ Toggle Camera View</button>
            <button onclick="toggleWireframe()">ðŸ•¸ Toggle Grid Mode</button>
        </div>
    </div>

    <script>
        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // Deep space blue
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(200, 200, 200);
        camera.lookAt(0,0,0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 2. ASSETS & MATERIALS ---
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Neon City Lights (Point Lights)
        const cityLight1 = new THREE.PointLight(0x00ffff, 2, 300);
        cityLight1.position.set(-100, 50, -100);
        scene.add(cityLight1);
        const cityLight2 = new THREE.PointLight(0xff00ff, 2, 300);
        cityLight2.position.set(100, 50, 100);
        scene.add(cityLight2);

        // Geometries
        const carGeo = new THREE.BoxGeometry(10, 6, 20); // Width, Height, Length
        const roadGeo = new THREE.PlaneGeometry(60, 600);
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);

        // Materials
        const roadMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, roughness: 0.2, metalness: 0.5 
        });
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x020202, roughness: 0.8 
        });
        const stopLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // --- 3. ENVIRONMENT BUILDING ---
        
        // Ground
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid Helper (Tron style)
        const gridHelper = new THREE.GridHelper(1000, 50, 0x00ffff, 0x111122);
        gridHelper.position.y = 0.1;
        scene.add(gridHelper);

        // Roads
        function createRoad(rotY) {
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.rotation.z = rotY;
            road.position.y = 0.2;
            road.receiveShadow = true;
            scene.add(road);
        }
        createRoad(0); // Vertical
        createRoad(Math.PI / 2); // Horizontal

        // Traffic Light Pillars
        const poleGeo = new THREE.CylinderGeometry(1, 1, 30, 8);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        
        const lights = { h: [], v: [] }; // Store meshes to change colors

        function createTrafficLight(x, z, axis) {
            const group = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 15;
            pole.castShadow = true;
            group.add(pole);

            // Box
            const box = new THREE.Mesh(new THREE.BoxGeometry(6, 12, 6), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            box.position.y = 28;
            group.add(box);

            // Light Bulb (The glowing part)
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            bulb.position.set(0, 28, 3.5);
            group.add(bulb);
            
            // Add PointLight for glow
            const glow = new THREE.PointLight(0xff0000, 2, 50);
            glow.position.set(0, 28, 5);
            group.add(glow);

            group.position.set(x, 0, z);
            // Rotate to face intersection
            if (axis === 'H') group.rotation.y = Math.PI / 2;
            
            scene.add(group);

            // Store ref to update color later
            const lightObj = { mesh: bulb, glow: glow };
            if (axis === 'H') lights.h.push(lightObj);
            else lights.v.push(lightObj);
        }

        createTrafficLight(-35, -35, 'V');
        createTrafficLight(35, 35, 'V');
        createTrafficLight(-35, 35, 'H');
        createTrafficLight(35, -35, 'H');


        // --- 4. GAME LOGIC (The Simulation) ---
        
        const STATE = {
            cars: [],
            phase: 'H_GREEN',
            lastSwitch: 0,
            frame: 0,
            simSpeed: 1.0
        };

        const LOGIC_CFG = { stopOffset: 45 };

        // Car Mesh Pool (Performance Optimization)
        // Instead of new Mesh() every spawn, we recycle them.
        const carMeshes = []; 
        function getCarMesh(color) {
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.1, metalness: 0.6 });
            const mesh = new THREE.Mesh(carGeo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add Headlights
            const headL = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 1), new THREE.MeshBasicMaterial({color: 0xffffaa}));
            headL.position.set(0, 0, 10.1); // Front
            mesh.add(headL);
            
            const tailL = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 1), new THREE.MeshBasicMaterial({color: 0xff0000}));
            tailL.position.set(0, 0, -10.1); // Back
            mesh.add(tailL);

            scene.add(mesh);
            return mesh;
        }

        class CarAgent {
            constructor(axis, dir) {
                this.axis = axis;
                this.dir = dir; // 1 or -1
                this.speed = 0;
                this.maxSpeed = 1.5 + Math.random() * 0.5; // ThreeJS units per frame
                
                // Logic Position (2D)
                if (axis === 'H') {
                    this.lx = (dir === 1) ? -300 : 300;
                    this.lz = (dir === 1) ? 15 : -15; // Right lane
                } else {
                    this.lx = (dir === 1) ? -15 : 15;
                    this.lz = (dir === 1) ? -300 : 300;
                }

                // 3D Mesh
                const color = Math.random() > 0.95 ? 0xffffff : Math.random() * 0xffffff; // 5% White (Police)
                this.mesh = getCarMesh(color);
                this.updateMesh();

                // Rotate mesh based on direction
                if (axis === 'H') this.mesh.rotation.y = (dir === 1) ? Math.PI/2 : -Math.PI/2;
                else this.mesh.rotation.y = (dir === 1) ? 0 : Math.PI;
            }

            updateMesh() {
                this.mesh.position.set(this.lx, 3, this.lz);
            }

            destroy() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }

            move() {
                // PHYSICS LOGIC (Same as before, simplified for 3D units)
                let target = this.maxSpeed;
                
                // Car Ahead
                const ahead = this.findAhead();
                if (ahead) {
                    const dist = (this.axis==='H') 
                        ? (ahead.lx - this.lx)*this.dir 
                        : (ahead.lz - this.lz)*this.dir;
                    
                    if (dist > 0 && dist < 40) target = 0;
                    else if (dist < 80) target *= 0.3;
                }

                // Traffic Light
                const stopLine = (this.dir === 1) ? -LOGIC_CFG.stopOffset : LOGIC_CFG.stopOffset;
                // Distance to center is easier
                const distToCenter = (this.axis === 'H') ? Math.abs(this.lx) : Math.abs(this.lz);
                const approaching = (this.axis==='H') ? (this.lx * this.dir < 0) : (this.lz * this.dir < 0);
                
                let red = false;
                if (approaching) {
                    if (this.axis === 'H' && STATE.phase.includes('V')) red = true;
                    if (this.axis === 'V' && STATE.phase.includes('H')) red = true;
                    if (STATE.phase.includes('YELLOW') && distToCenter < 60) red = false; // Run yellow if close
                    else if (STATE.phase.includes('YELLOW') && STATE.phase.includes(this.axis)) red = true;
                }

                if (red && distToCenter < 60 && distToCenter > 30) {
                    target = 0;
                }

                if (this.speed < target) this.speed += 0.05;
                else this.speed -= 0.1;
                if (this.speed < 0) this.speed = 0;

                // Apply Move
                if (this.axis === 'H') this.lx += this.speed * this.dir;
                else this.lz += this.speed * this.dir;

                this.updateMesh();
            }

            findAhead() {
                // Simple search
                let min = Infinity;
                let closest = null;
                STATE.cars.forEach(c => {
                    if (c === this || c.axis !== this.axis || c.dir !== this.dir) return;
                    const dist = (this.axis==='H') ? (c.lx - this.lx)*this.dir : (c.lz - this.lz)*this.dir;
                    if (dist > 0 && dist < min) { min = dist; closest = c; }
                });
                return closest;
            }
        }


        // --- 5. CONTROLLER ---

        function updateLights() {
            // Colors
            const H_COL = STATE.phase.includes('H_GREEN') ? 0x00ff00 : (STATE.phase === 'H_YELLOW' ? 0xffff00 : 0xff0000);
            const V_COL = STATE.phase.includes('V_GREEN') ? 0x00ff00 : (STATE.phase === 'V_YELLOW' ? 0xffff00 : 0xff0000);

            lights.h.forEach(l => { l.mesh.material.color.setHex(H_COL); l.glow.color.setHex(H_COL); });
            lights.v.forEach(l => { l.mesh.material.color.setHex(V_COL); l.glow.color.setHex(V_COL); });
            
            document.getElementById('ui-phase').innerText = STATE.phase;
            document.getElementById('ui-phase').style.color = STATE.phase.includes('GREEN') ? 'lime' : (STATE.phase.includes('YELLOW')?'yellow':'red');
        }

        function runLogic() {
            STATE.frame++;
            
            // AI Controller
            const hQ = STATE.cars.filter(c => c.axis==='H' && c.speed < 0.1).length;
            const vQ = STATE.cars.filter(c => c.axis==='V' && c.speed < 0.1).length;
            
            const time = STATE.frame - STATE.lastSwitch;
            
            // Pressure System AI
            if (STATE.phase === 'H_GREEN') {
                if (time > 120 && (vQ > hQ + 1 || hQ === 0)) { STATE.phase = 'H_YELLOW'; STATE.lastSwitch = STATE.frame; }
            } else if (STATE.phase === 'H_YELLOW' && time > 60) {
                 STATE.phase = 'V_GREEN'; STATE.lastSwitch = STATE.frame;
            } else if (STATE.phase === 'V_GREEN') {
                if (time > 120 && (hQ > vQ + 1 || vQ === 0)) { STATE.phase = 'V_YELLOW'; STATE.lastSwitch = STATE.frame; }
            } else if (STATE.phase === 'V_YELLOW' && time > 60) {
                STATE.phase = 'H_GREEN'; STATE.lastSwitch = STATE.frame;
            }

            updateLights();

            // Spawner
            const rateH = document.getElementById('rate-h').value / 2000;
            const rateV = document.getElementById('rate-v').value / 2000;

            if (Math.random() < rateH) STATE.cars.push(new CarAgent('H', 1));
            if (Math.random() < rateH) STATE.cars.push(new CarAgent('H', -1));
            if (Math.random() < rateV) STATE.cars.push(new CarAgent('V', 1));
            if (Math.random() < rateV) STATE.cars.push(new CarAgent('V', -1));

            // Move Cars
            STATE.cars.forEach(c => c.move());
            
            // Cleanup
            for (let i = STATE.cars.length - 1; i >= 0; i--) {
                const c = STATE.cars[i];
                if (Math.abs(c.lx) > 350 || Math.abs(c.lz) > 350) {
                    c.destroy();
                    STATE.cars.splice(i, 1);
                }
            }
            
            document.getElementById('ui-cars').innerText = STATE.cars.length;
        }

        // --- 6. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            runLogic();
            controls.update();
            renderer.render(scene, camera);
        }

        // --- EXTRAS ---
        function toggleWireframe() {
            ground.visible = !ground.visible;
        }
        
        let camMode = 0;
        function toggleCam() {
            camMode = (camMode + 1) % 3;
            if (camMode === 0) { // Default
                camera.position.set(200, 200, 200);
                camera.lookAt(0,0,0);
            } else if (camMode === 1) { // Top Down
                camera.position.set(0, 400, 0);
                camera.lookAt(0,0,0);
            } else { // Street Level
                camera.position.set(-50, 20, -50);
                camera.lookAt(20, 0, 20);
            }
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>