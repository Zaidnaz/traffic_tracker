<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Traffic Lab Pro</title>
    <style>
        :root { --bg: #0f172a; --panel: rgba(15, 23, 42, 0.95); --border: #334155; --accent: #38bdf8; }
        body { margin: 0; background: var(--bg); overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; color: #e2e8f0; user-select: none; }
        
        /* DASHBOARD LAYOUT */
        #ui-layer { position: absolute; top: 0; left: 0; width: 320px; height: 100vh; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 15px; pointer-events: none; z-index: 10; }
        
        .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 12px; pointer-events: auto; backdrop-filter: blur(8px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); }
        
        h3 { margin: 0 0 10px 0; font-size: 11px; text-transform: uppercase; color: #94a3b8; letter-spacing: 1px; border-bottom: 1px solid var(--border); padding-bottom: 4px; display: flex; justify-content: space-between; }
        
        /* CONTROLS */
        .slider-group { margin-bottom: 8px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 10px; color: #cbd5e1; margin-bottom: 2px; }
        input[type=range] { width: 100%; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #334155; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; }

        button { width: 100%; padding: 8px; background: #1e293b; border: 1px solid var(--border); color: white; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s; margin-bottom: 5px; }
        button:hover { background: #334155; }
        button.primary { background: var(--accent); color: #0f172a; border: none; }
        button.primary:hover { opacity: 0.9; }

        /* METRICS */
        .metric-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; font-family: 'Consolas', monospace; }
        .val { color: var(--accent); font-weight: bold; }
        
        canvas#graph { width: 100%; height: 80px; background: #1e293b; border: 1px solid var(--border); border-radius: 4px; margin-top: 5px; }

        /* NOTIFICATIONS */
        #toast { position: absolute; bottom: 20px; right: 20px; background: var(--accent); color: #0f172a; padding: 10px 20px; border-radius: 4px; font-weight: bold; transform: translateY(100px); transition: transform 0.3s; }
        #toast.show { transform: translateY(0); }
    </style>
</head>
<body>

    <div id="ui-layer">
        
        <div class="panel">
            <h3>Simulation Status <span id="clock">00:00</span></h3>
            <div class="metric-row"><span>Algorithm:</span> <span id="algo-disp" style="color:#4ade80">Smart AI</span></div>
            <div class="metric-row"><span>Throughput:</span> <span class="val" id="disp-cpm">0</span> cpm</div>
            <div class="metric-row"><span>Avg Wait:</span> <span class="val" id="disp-wait">0.0</span> sec</div>
            <canvas id="graph" width="280" height="80"></canvas>
            <div style="font-size:9px; color:#64748b; text-align:center">Wait Time History (1 min)</div>
        </div>

        <div class="panel">
            <h3>Flow Control (Asymmetric)</h3>
            
            <div class="slider-group">
                <div class="slider-label"><span>Horizontal Flow (West/East)</span> <span id="val-h">50%</span></div>
                <input type="range" min="0" max="100" value="50" oninput="updateRate('h', this.value)">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>Vertical Flow (North/South)</span> <span id="val-v">30%</span></div>
                <input type="range" min="0" max="100" value="30" oninput="updateRate('v', this.value)">
            </div>

            <div style="margin-top:10px; border-top:1px dashed #334155; padding-top:10px;">
                <button onclick="toggleTime()" id="btn-time">üåû Toggle Night Mode</button>
                <button onclick="setAlgorithm()" id="btn-algo">üß† AI / ‚è± Timer</button>
            </div>
        </div>

        <div class="panel">
            <h3>Research Tools</h3>
            <button class="primary" onclick="exportData()">üì• Download CSV Data</button>
            <button class="danger" onclick="resetSim()" style="color:#f87171; border-color:#7f1d1d">‚ö† Reset Simulation</button>
        </div>

    </div>

    <div id="toast">Data Exported!</div>
    <canvas id="sim"></canvas>

    <script>
        const canvas = document.getElementById('sim');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graph');
        const graphCtx = graphCanvas.getContext('2d');
        
        // RESIZE
        let w, h;
        const resize = () => { w = window.innerWidth; h = window.innerHeight; canvas.width = w; canvas.height = h; };
        window.addEventListener('resize', resize);
        resize();

        // --- CONFIG & STATE ---
        const CFG = { road: 140, carW: 28, carL: 46, stop: 110 };
        const STATE = {
            cars: [],
            phase: 'H_GREEN',
            lastSwitch: 0,
            frame: 0,
            rates: { h: 0.05, v: 0.03 }, // Spawn probabilities
            isNight: true,
            isAI: true,
            // Data Collecting
            dataLog: [], // Stores [Time, H_Queue, V_Queue, AvgWait]
            completedTrips: 0,
            totalWait: 0,
            startTime: Date.now()
        };

        // --- CLASSES ---
        class Car {
            constructor(axis, dir) {
                this.axis = axis; // 'H' or 'V'
                this.dir = dir;   // 1 (Right/Down) or -1 (Left/Up)
                
                // Dimensions (Swapped for H/V)
                this.w = (axis === 'H') ? CFG.carL : CFG.carW;
                this.h = (axis === 'H') ? CFG.carW : CFG.carL;
                
                // Start Position
                if (axis === 'H') {
                    this.x = (dir === 1) ? -100 : w + 100;
                    this.y = h/2 + (dir * 20); // Lane offset
                } else {
                    this.x = w/2 - (dir * 20);
                    this.y = (dir === 1) ? -100 : h + 100;
                }

                // Stats
                this.speed = 0;
                this.maxSpeed = 6 + Math.random() * 3;
                this.waitFrameCount = 0;
                this.entryTime = Date.now();
                
                // Visuals
                this.color = `hsl(${Math.random()*360}, 70%, 50%)`;
                this.isEmergency = Math.random() < 0.02;
            }

            update() {
                // 1. Target Speed Calculation
                let target = this.maxSpeed;

                // Car Ahead
                const ahead = this.findAhead();
                if (ahead) {
                    const dist = Math.abs((this.axis==='H' ? ahead.x - this.x : ahead.y - this.y));
                    if (dist < 120) target = Math.min(target, (dist - 70) * 0.1);
                }

                // Traffic Light
                const stopLine = (this.axis==='H') ? w/2 - (this.dir*CFG.stop) : h/2 - (this.dir*CFG.stop);
                const distToLine = (this.axis==='H') ? (stopLine - this.x)*this.dir : (stopLine - this.y)*this.dir;
                
                let isRed = false;
                // Logic: If I am H, and V is Green -> Red.
                if (this.axis === 'H' && STATE.phase.includes('V')) isRed = true;
                if (this.axis === 'V' && STATE.phase.includes('H')) isRed = true;
                // Yellow Logic
                if (STATE.phase.includes('YELLOW')) {
                    // If yellow matching my axis, stop if I can
                    if (STATE.phase.includes(this.axis) && distToLine > 60) isRed = true;
                }

                if (isRed && distToLine > 0 && distToLine < 150) {
                    target = Math.min(target, (distToLine - 20) * 0.08);
                }

                // Physics
                if (this.speed < target) this.speed += 0.2;
                else this.speed -= 0.4;
                if (this.speed < 0) this.speed = 0;

                // Move
                if (this.axis === 'H') this.x += this.speed * this.dir;
                else this.y += this.speed * this.dir;

                // Collect Wait Time
                if (this.speed < 1 && distToLine > 0 && distToLine < 200) this.waitFrameCount++;
            }

            findAhead() {
                let closest = null, min = Infinity;
                STATE.cars.forEach(c => {
                    if (c.axis !== this.axis || c.dir !== this.dir || c === this) return;
                    // Check if c is ahead
                    const dist = (this.axis==='H') ? (c.x - this.x)*this.dir : (c.y - this.y)*this.dir;
                    if (dist > 0 && dist < min) { min = dist; closest = c; }
                });
                return closest;
            }

            draw() {
                const x = this.x, y = this.y;
                // 2.5D Projection
                const lift = -12; 
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(x+8, y+8, this.w, this.h);

                // Body (Side)
                ctx.fillStyle = '#1e293b'; 
                ctx.fillRect(x, y, this.w, this.h);
                
                // Body (Top)
                ctx.fillStyle = this.isEmergency ? '#fff' : this.color;
                ctx.fillRect(x, y+lift, this.w, this.h);

                // Lights
                if (STATE.isNight) {
                    // Headlights
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    const grad = ctx.createLinearGradient(0,0, (this.axis==='H'?200:0), (this.axis==='V'?200:0));
                    grad.addColorStop(0, 'rgba(255,255,200,0.4)'); 
                    grad.addColorStop(1, 'rgba(255,255,200,0)');
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    // Simplified Cone drawing based on direction...
                    // (Omitted slightly for brevity, basic glow:)
                    ctx.arc(x+this.w/2, y+this.h/2 + lift, 40, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                // Brake Lights
                if (this.speed < 0.5) {
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 10;
                    // Logic to place red dots at "rear" based on direction
                    // ... (simplified center glow for code golf)
                    ctx.fillRect(x + this.w/2 - 2, y + lift + this.h/2 - 2, 4, 4);
                    ctx.shadowBlur = 0;
                }
            }
        }

        // --- CORE SYSTEMS ---

        function updateRate(axis, val) {
            STATE.rates[axis] = val / 1000; // Map 0-100 to probability
            document.getElementById(`val-${axis}`).innerText = val + "%";
        }

        function toggleTime() {
            STATE.isNight = !STATE.isNight;
            document.getElementById('btn-time').innerText = STATE.isNight ? "üåû Toggle Day Mode" : "üåô Toggle Night Mode";
        }

        function setAlgorithm() {
            STATE.isAI = !STATE.isAI;
            const el = document.getElementById('algo-disp');
            el.innerText = STATE.isAI ? "Smart AI" : "Fixed Timer";
            el.style.color = STATE.isAI ? "#4ade80" : "#fbbf24";
        }

        function exportData() {
            let csv = "Time_Sec,H_Queue,V_Queue,Phase\n";
            STATE.dataLog.forEach(row => {
                csv += `${row.time},${row.h},${row.v},${row.p}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'traffic_data.csv';
            a.click();
            
            const t = document.getElementById('toast');
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        function resetSim() {
            STATE.cars = [];
            STATE.dataLog = [];
            STATE.completedTrips = 0;
            STATE.totalWait = 0;
            STATE.startTime = Date.now();
        }

        // --- LOOP ---
        function loop() {
            STATE.frame++;
            const now = Date.now();
            
            // 1. Spawner (Asymmetric)
            if (Math.random() < STATE.rates.h) STATE.cars.push(new Car('H', 1)); // West -> East
            if (Math.random() < STATE.rates.h) STATE.cars.push(new Car('H', -1)); // East -> West
            if (Math.random() < STATE.rates.v) STATE.cars.push(new Car('V', 1)); // North -> South
            if (Math.random() < STATE.rates.v) STATE.cars.push(new Car('V', -1)); // South -> North

            // 2. Logic & Stats
            const hQ = STATE.cars.filter(c => c.axis==='H' && c.speed < 1).length;
            const vQ = STATE.cars.filter(c => c.axis==='V' && c.speed < 1).length;
            
            // AI Controller
            const timeInPhase = STATE.frame - STATE.lastSwitch;
            if (STATE.isAI) {
                // Pressure System
                if (STATE.phase === 'H_GREEN' && timeInPhase > 120) {
                    if (vQ > hQ + 2 || (hQ === 0 && vQ > 0)) switchP('H_YELLOW');
                } else if (STATE.phase === 'H_YELLOW' && timeInPhase > 90) {
                    switchP('V_GREEN');
                } else if (STATE.phase === 'V_GREEN' && timeInPhase > 120) {
                    if (hQ > vQ + 2 || (vQ === 0 && hQ > 0)) switchP('V_YELLOW');
                } else if (STATE.phase === 'V_YELLOW' && timeInPhase > 90) {
                    switchP('H_GREEN');
                }
            } else {
                // Dumb Timer (300 frames = ~5s)
                if (timeInPhase > 400 && !STATE.phase.includes('YELLOW')) {
                    switchP(STATE.phase.includes('H') ? 'H_YELLOW' : 'V_YELLOW');
                } else if (timeInPhase > 120 && STATE.phase.includes('YELLOW')) {
                    switchP(STATE.phase.includes('H') ? 'V_GREEN' : 'H_GREEN');
                }
            }

            // 3. Update Cars
            STATE.cars.forEach(c => c.update());
            STATE.cars = STATE.cars.filter(c => {
                const active = (c.x > -150 && c.x < w+150 && c.y > -150 && c.y < h+150);
                if (!active) {
                    STATE.completedTrips++;
                    STATE.totalWait += (c.waitFrameCount / 60);
                }
                return active;
            });

            // 4. Data Logging (Every 1s / 60 frames)
            if (STATE.frame % 60 === 0) {
                const runTime = Math.floor((now - STATE.startTime)/1000);
                document.getElementById('clock').innerText = new Date(runTime * 1000).toISOString().substr(14, 5);
                
                // Log
                STATE.dataLog.push({ time: runTime, h: hQ, v: vQ, p: STATE.phase });
                
                // Update Metrics UI
                const mins = runTime / 60;
                const cpm = mins > 0 ? (STATE.completedTrips / mins).toFixed(1) : 0;
                const avgWait = STATE.completedTrips > 0 ? (STATE.totalWait / STATE.completedTrips).toFixed(1) : 0;
                
                document.getElementById('disp-cpm').innerText = cpm;
                document.getElementById('disp-wait').innerText = avgWait;
                
                updateGraph(avgWait);
            }

            // 5. Render
            ctx.fillStyle = STATE.isNight ? '#0f172a' : '#334155'; // Day/Night BG
            ctx.fillRect(0,0,w,h);
            drawEnv();
            
            // Depth Sort
            STATE.cars.sort((a,b) => a.y - b.y);
            STATE.cars.forEach(c => c.draw());

            requestAnimationFrame(loop);
        }

        function switchP(p) {
            STATE.phase = p;
            STATE.lastSwitch = STATE.frame;
        }

        function drawEnv() {
            const rw = CFG.road;
            ctx.fillStyle = STATE.isNight ? '#1e293b' : '#475569'; // Road Color
            ctx.fillRect(0, h/2 - rw/2, w, rw);
            ctx.fillRect(w/2 - rw/2, 0, rw, h);
            
            // Stop Lines
            const stop = CFG.stop;
            const hCol = STATE.phase.includes('H') ? '#22c55e' : '#ef4444';
            const vCol = STATE.phase.includes('V') ? '#22c55e' : '#ef4444';
            
            ctx.lineWidth = 6;
            ctx.shadowBlur = STATE.isNight ? 15 : 0;
            
            ctx.strokeStyle = hCol; ctx.shadowColor = hCol;
            ctx.beginPath(); ctx.moveTo(w/2 - stop, h/2); ctx.lineTo(w/2 - stop, h/2+rw/2); ctx.stroke(); // Left
            ctx.beginPath(); ctx.moveTo(w/2 + stop, h/2); ctx.lineTo(w/2 + stop, h/2-rw/2); ctx.stroke(); // Right (Inverted for realism)

            ctx.strokeStyle = vCol; ctx.shadowColor = vCol;
            ctx.beginPath(); ctx.moveTo(w/2 - rw/2, h/2 - stop); ctx.lineTo(w/2, h/2 - stop); ctx.stroke(); // Top
            ctx.beginPath(); ctx.moveTo(w/2 + rw/2, h/2 + stop); ctx.lineTo(w/2, h/2 + stop); ctx.stroke(); // Bottom

            ctx.shadowBlur = 0;
        }

        // --- GRAPH ---
        let graphHistory = new Array(30).fill(0);
        function updateGraph(val) {
            graphHistory.push(parseFloat(val));
            graphHistory.shift();
            
            graphCtx.fillStyle = '#1e293b';
            graphCtx.fillRect(0,0,280,80);
            
            graphCtx.strokeStyle = '#38bdf8';
            graphCtx.beginPath();
            const max = Math.max(10, ...graphHistory);
            
            graphHistory.forEach((v, i) => {
                const x = (i/29) * 280;
                const y = 80 - (v/max * 80);
                if (i===0) graphCtx.moveTo(x,y); else graphCtx.lineTo(x,y);
            });
            graphCtx.stroke();
        }

        loop();
    </script>
</body>
</html>